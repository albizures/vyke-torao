<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>snake</title>
		<style>
			body {
				margin: 0;
				padding: 0;
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				background-color: #f0f0f0;
				overflow: hidden;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
  </head>
  <body>
    <canvas style="border: 1px solid black"></canvas>
  </body>
</html>

<script>
import type { Vec2D } from '../../src/vec'
import { AtlasType, createTexture } from '../../src'
import { createTransform2D, type MaybeWithTransform2D, type MaybeWithVelocity2D } from '../../src/components'
import { createQuery, createSystem, SystemType } from '../../src/ecs'
import { createGame, start } from '../../src/game'
import { createCamera2d, type MaybeWithCamera2D } from '../../src/prefabs'
import { type MaybeWithTexture2d, renderer2d } from '../../src/renderers/renderer2d'
import { assets, textures } from '../definitions'

type MyEntity = MaybeWithTransform2D & MaybeWithTexture2d & MaybeWithVelocity2D & MaybeWithCamera2D & {
	borderBehavior?: BorderBehaviorValue
	grid?: GridValue
	head?: HeadValue
	direction?: DirectionValue
	prevPosition?: Vec2D
	tail?: TailValue
}

const INITIAL_SIZE = 4
const GRID_SIZE = 20
const CELL_SIZE = 10
const VELOCITY = 2

type BorderBehaviorValue = {
	type: 'wrap' | 'die'
}

type GridValue = {
	size: Vec2D
}

type HeadValue = {
	position: Vec2D
}

enum DirectionType {
	Up = 0,
	Down = 1,
	Left = 2,
	Right = 3,
}

type DirectionValue = {
	dir: DirectionType
}

type TailValue = {
	position: Vec2D
	direction: DirectionType
	follow: string
}

const { game, createScene } = createGame<
	MyEntity,
	typeof assets,
	typeof textures
>({
	canvas: {
		element: document.querySelector('canvas')!,
		resizeMode: 'fill',
	},
	assets,
	textures,
})

const allHeads = createQuery<MyEntity>({
	id: 'all-heads',
	with: ['head', 'transform2D', 'borderBehavior', 'prevPosition', 'velocity2D'],
})

const allTails = createQuery<MyEntity>({
	id: 'all-tails',
	with: ['tail', 'transform2D', 'prevPosition'],
})

const allGrids = createQuery<MyEntity>({
	id: 'all-grids',
	with: ['grid', 'transform2D'],
})

const move = createSystem<MyEntity>({
	id: 'move',
	type: SystemType.FixedUpdate,
	fn(args) {
		const { select } = args

		for (const item of select(allHeads)) {
			const { direction, velocity2D, head } = item

			switch (direction.dir) {
				case DirectionType.Up:
					head.position.y -= velocity2D.y
					break
				case DirectionType.Down:
					head.position.y += velocity2D.y
					break
				case DirectionType.Left:
					head.position.x -= velocity2D.x
					break
				case DirectionType.Right:
					head.position.x += velocity2D.x
					break
			}
		}
	},
})

const snapToGrid = createSystem<MyEntity>({
	id: 'snap-to-grid',
	type: SystemType.FixedUpdate,
	fn(args) {
		const { select } = args

		const offset = select(allGrids).first()!.transform2D.position

		for (const item of select(allHeads)) {
			const { transform2D, head, prevPosition } = item
			const position = transform2D.position

			const inGridX = head.position.x + offset.x
			const inGridY = head.position.y + offset.y

			const x = Math.round(inGridX / CELL_SIZE) * CELL_SIZE
			const y = Math.round(inGridY / CELL_SIZE) * CELL_SIZE

			if (x !== position.x || y !== position.y) {
				prevPosition.x = position.x
				prevPosition.y = position.y
				position.x = x
				position.y = y
			}
		}
	},
})

const borderBehavior = createSystem<MyEntity>({
	id: 'border-behavior',
	type: SystemType.FixedUpdate,
	fn(args) {
		const { select } = args
		const { grid: gridValues } = select(allGrids).first()!

		const canvasSize = {
			x: gridValues.size.x * GRID_SIZE,
			y: gridValues.size.y * GRID_SIZE,
		}

		for (const item of select(allHeads)) {
			const { borderBehavior, head } = item
			const { position } = head

			if (borderBehavior.type === 'die') {
				if (position.x < 0 || position.x > canvasSize.x || position.y < 0 || position.y > canvasSize.y) {
					// console.log('die')
				}

				continue
			}

			if (position.x <= 0) {
				position.x = canvasSize.x - CELL_SIZE
			}
			else if (position.x > canvasSize.x - CELL_SIZE) {
				position.x = 0
			}

			if (position.y <= 0) {
				position.y = canvasSize.y - CELL_SIZE
			}
			else if (position.y > canvasSize.y - CELL_SIZE) {
				position.y = 0
			}
		}
	},
})

const followSystem = createSystem<MyEntity>({
	id: 'follow',
	type: SystemType.FixedUpdate,
	fn(args) {
		const { select, getEntity } = args

		for (const item of select(allTails)) {
			const { tail: tailValues, transform2D, prevPosition } = item
			const { follow } = tailValues

			const followPrevPosition = getEntity(follow)?.prevPosition
			const position = transform2D.position

			if (followPrevPosition && (followPrevPosition.x !== position.x || followPrevPosition.y !== position.y)) {
				prevPosition.x = position.x
				prevPosition.y = position.y
				position.x = followPrevPosition!.x
				position.y = followPrevPosition!.y
			}
		}
	},
})

const home = createScene('home', (context) => {
	const { spawn } = context
	const strokeSize = 2
	const gridSize = GRID_SIZE * CELL_SIZE + strokeSize
	const gridTexture = createTexture({
		asset: assets.grid,
		atlas: {
			type: AtlasType.Single,
			region: {
				width: gridSize,
				height: gridSize,
			},
		},
	})

	assets.grid.loader.onLoad((context) => {
		const { canvas } = context

		canvas.width = gridSize
		canvas.height = gridSize

		context.strokeStyle = 'red'
		context.strokeRect(1, 1, gridSize - strokeSize, gridSize - strokeSize)
	})

	const squareTexture = createTexture({
		asset: assets.square,
		atlas: {
			type: AtlasType.Single,
			region: {
				width: CELL_SIZE,
				height: CELL_SIZE,
			},
		},
	})

	assets.square.loader.onLoad((context) => {
		const { canvas } = context

		canvas.width = CELL_SIZE
		canvas.height = CELL_SIZE

		context.fillStyle = 'green'
		context.fillRect(0, 0, CELL_SIZE, CELL_SIZE)
	})

	spawn('grid', {
		grid: {
			size: { x: CELL_SIZE, y: CELL_SIZE },
		},
		transform2D: createTransform2D({
			position: { x: 20, y: 20 },
		}),
		texture2D: gridTexture,
	})

	const startX = 80

	spawn('head', {
		head: {
			position: { x: startX, y: 20 },
		},
		borderBehavior: {
			type: 'wrap',
		},
		velocity2D: {
			x: VELOCITY,
			y: VELOCITY,
		},
		transform2D: createTransform2D({
			position: { x: startX + CELL_SIZE, y: 30 },
		}),
		prevPosition: { x: startX, y: 30 },
		direction: { dir: DirectionType.Right },
		texture2D: squareTexture,
	})

	let follow = 'head'

	for (let index = 0; index < INITIAL_SIZE; index++) {
		const currentId = `tail-${index}`
		spawn(currentId, {
			tail: {
				position: {
					x: startX - ((index + 1) * CELL_SIZE) + CELL_SIZE,
					y: 20,
				},
				direction: DirectionType.Right,
				follow,
			},
			transform2D: createTransform2D({
				position: {
					x: startX - (index * CELL_SIZE),
					y: 30,
				},
			}),
			prevPosition: {
				x: startX - ((index - 1) * CELL_SIZE),
				y: 30,
			},
			texture2D: squareTexture,
		})
		follow = currentId
	}

	spawn('camera', createCamera2d())

	return {
		systems: [
			...renderer2d.systems,
			snapToGrid,
			followSystem,
			move,
			borderBehavior,

		],
	}
})

home.world.registerQuery(allHeads)
home.world.registerQuery(allTails)
home.world.registerQuery(allGrids)

renderer2d.queries.forEach((query) => home.world.registerQuery(query))

document.addEventListener('keydown', (event) => {
	for (const head of home.world.select(allHeads)) {
		const { direction } = head
		const { dir } = direction
		switch (event.key) {
			case 'ArrowUp':
				if (dir !== DirectionType.Down) {
					direction.dir = DirectionType.Up
				}
				break
			case 'ArrowDown':
				if (dir !== DirectionType.Up) {
					direction.dir = DirectionType.Down
				}
				break
			case 'ArrowLeft':
				if (dir !== DirectionType.Right) {
					direction.dir = DirectionType.Left
				}
				break
			case 'ArrowRight':
				if (dir !== DirectionType.Left) {
					direction.dir = DirectionType.Right
				}
				break
		}
	}
})

start(game, home)
</script>
